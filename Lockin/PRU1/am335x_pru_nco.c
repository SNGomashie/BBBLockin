#ifndef __AM335X_PRU_NCO_C_
#define __AM335X_PRU_NCO_C_

#include <stdio.h>
#include <stdint.h>
#include "am335x_pru_nco.h"

const uint16_t sinLUT[257] = {0x199a,0x1a3a,0x1adb,0x1b7c,0x1c1c,0x1cbc,0x1d5b,0x1dfa,0x1e98,0x1f35,0x1fd2,0x206d,0x2108,0x21a1,0x2239,0x22d0,0x2365,0x23f9,0x248b,0x251c,0x25ab,0x2638,0x26c3,0x274c,0x27d2,0x2857,0x28d9,0x2959,0x29d7,0x2a52,0x2acb,0x2b40,0x2bb4,0x2c24,0x2c91,0x2cfc,0x2d63,0x2dc8,0x2e29,0x2e88,0x2ee3,0x2f3a,0x2f8f,0x2fe0,0x302d,0x3077,0x30be,0x3101,0x3140,0x317c,0x31b4,0x31e8,0x3219,0x3246,0x326f,0x3294,0x32b5,0x32d3,0x32ec,0x3302,0x3313,0x3321,0x332b,0x3331,0x3333,0x3331,0x332b,0x3321,0x3313,0x3302,0x32ec,0x32d3,0x32b5,0x3294,0x326f,0x3246,0x3219,0x31e8,0x31b4,0x317c,0x3140,0x3101,0x30be,0x3077,0x302d,0x2fe0,0x2f8f,0x2f3a,0x2ee3,0x2e88,0x2e29,0x2dc8,0x2d63,0x2cfc,0x2c91,0x2c24,0x2bb4,0x2b40,0x2acb,0x2a52,0x29d7,0x2959,0x28d9,0x2857,0x27d2,0x274c,0x26c3,0x2638,0x25ab,0x251c,0x248b,0x23f9,0x2365,0x22d0,0x2239,0x21a1,0x2108,0x206d,0x1fd2,0x1f35,0x1e98,0x1dfa,0x1d5b,0x1cbc,0x1c1c,0x1b7c,0x1adb,0x1a3a,0x199a,0x18f9,0x1858,0x17b7,0x1717,0x1677,0x15d8,0x1539,0x149b,0x13fe,0x1361,0x12c6,0x122b,0x1192,0x10fa,0x1063,0xfce,0xf3a,0xea8,0xe17,0xd88,0xcfb,0xc70,0xbe7,0xb61,0xadc,0xa5a,0x9da,0x95c,0x8e1,0x868,0x7f3,0x77f,0x70f,0x6a2,0x637,0x5d0,0x56b,0x50a,0x4ab,0x450,0x3f9,0x3a4,0x353,0x306,0x2bc,0x275,0x232,0x1f3,0x1b7,0x17f,0x14b,0x11a,0xed,0xc4,0x9f,0x7e,0x60,0x47,0x31,0x20,0x12,0x8,0x2,0x0,0x2,0x8,0x12,0x20,0x31,0x47,0x60,0x7e,0x9f,0xc4,0xed,0x11a,0x14b,0x17f,0x1b7,0x1f3,0x232,0x275,0x2bc,0x306,0x353,0x3a4,0x3f9,0x450,0x4ab,0x50a,0x56b,0x5d0,0x637,0x6a2,0x70f,0x77f,0x7f3,0x868,0x8e1,0x95c,0x9da,0xa5a,0xadc,0xb61,0xbe7,0xc70,0xcfb,0xd88,0xe17,0xea8,0xf3a,0xfce,0x1063,0x10fa,0x1192,0x122b,0x12c6,0x1361,0x13fe,0x149b,0x1539,0x15d8,0x1677,0x1717,0x17b7,0x1858,0x18f9,0x199a};


void NCOinitialize(struct NCO *n, uint32_t samp_period){
  n->period = &CT_ECAP.CAP1;
  n->sin_accumulator = 0;
  n->cos_accumulator = (64 <<  16);
  n->sample_period = samp_period;
  n->sin_output = sinLUT[0];
  n->cos_output = sinLUT[64];
  NCOsetfreq(n);
}

void NCOsetfreq(struct NCO *n){
  uint32_t norm_period = 0;
  uint32_t temp_period = 0;

  temp_period = *(n->period) / 100;
  norm_period = P2_24 / temp_period;
  n->incrementor = (uint64_t)norm_period * (uint64_t)n->sample_period;
}

void NCOinterpolate(struct NCO *n){
  uint32_t sin_index, cos_index = 0;
  uint32_t sin_out1, sin_out2 = 0;
  uint32_t cos_out1, cos_out2 = 0;
  uint32_t sin_fraction, cos_fraction = 0;
  uint64_t sin_diff_x_frac, cos_diff_x_frac = 0;
  uint32_t sin_temp_out, cos_temp_out = 0;
  int32_t sin_diff, cos_diff = 0;

  /* Extract int part of accumulator */
  sin_index = n->sin_accumulator >> 16;
  cos_index = n->cos_accumulator >> 16;
  /* Find LUT output and next output */
  sin_out1 = sinLUT[sin_index];
  sin_out2 = sinLUT[sin_index + 1];

  cos_out1 = sinLUT[cos_index];
  cos_out2 = sinLUT[cos_index + 1];

  /* Ectract frac part of accumulator */
  sin_fraction = 0xFFFF & n->sin_accumulator;
  cos_fraction = 0xFFFF & n->cos_accumulator;
  /* Calculate the difference between the 2 samples */
  sin_diff = sin_out2-sin_out1;
  cos_diff = cos_out2-cos_out1;
  /* Multiply by frac part of accumulator */
  sin_diff_x_frac = (int32_t)sin_diff * (uint32_t)sin_fraction;
  cos_diff_x_frac = (int32_t)cos_diff * (uint32_t)cos_fraction;
  /*      Mask least significant 32-bits      */
  /* because we multiply unsigned with signed */
  sin_temp_out = sin_diff_x_frac & 0xFFFFFFFF;
  cos_temp_out = cos_diff_x_frac & 0xFFFFFFFF;

    /*           division by 2^16             */
    /* if temp_out signed convert to unsigned */
    /* after division convert back to signed  */
    /*    if temp_out unsigned just divide    */
    if(sin_temp_out & (1 << 31)){
      sin_temp_out = ~sin_temp_out + 1;
      sin_temp_out /= P2_16;
      sin_temp_out = ~sin_temp_out + 1;
    } else {
      sin_temp_out /= P2_16;
    }

    if(cos_temp_out & (1 << 31)){
      cos_temp_out = ~cos_temp_out + 1;
      cos_temp_out /= P2_16;
      cos_temp_out = ~cos_temp_out + 1;
    } else {
      cos_temp_out /= P2_16;
    }
    n->sin_output = (sin_out1 + sin_temp_out);
    n->cos_output = (cos_out1 + cos_temp_out);
}

void NCOstep(struct NCO *n){
  NCOinterpolate(n);
  n->sin_accumulator = n->sin_accumulator + n->incrementor;
  n->cos_accumulator = n->cos_accumulator + n->incrementor;
  n->sin_accumulator &= (P2_24) - 1;
  n->cos_accumulator &= (P2_24) - 1;
}

#endif
