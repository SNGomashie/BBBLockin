#ifndef __AM335X_PRU_NCO_C_
#define __AM335X_PRU_NCO_C_

#include <stdio.h>
#include <stdint.h>
#include "am335x_pru_nco.h"

const uint16_t sinLUT[257] = {0x8000,0x8324,0x8647,0x896a,0x8c8b,0x8fab,0x92c7,0x95e1,0x98f8,0x9c0b,0x9f19,0xa223,0xa527,0xa826,0xab1f,0xae10,0xb0fb,0xb3de,0xb6b9,0xb98c,0xbc56,0xbf17,0xc1cd,0xc47a,0xc71c,0xc9b3,0xcc3f,0xcebf,0xd133,0xd39a,0xd5f5,0xd842,0xda82,0xdcb3,0xded7,0xe0eb,0xe2f1,0xe4e8,0xe6cf,0xe8a6,0xea6d,0xec23,0xedc9,0xef5e,0xf0e2,0xf254,0xf3b5,0xf504,0xf641,0xf76b,0xf884,0xf989,0xfa7c,0xfb5c,0xfc29,0xfce3,0xfd89,0xfe1d,0xfe9c,0xff09,0xff61,0xffa6,0xffd8,0xfff5,0xffff,0xfff5,0xffd8,0xffa6,0xff61,0xff09,0xfe9c,0xfe1d,0xfd89,0xfce3,0xfc29,0xfb5c,0xfa7c,0xf989,0xf884,0xf76b,0xf641,0xf504,0xf3b5,0xf254,0xf0e2,0xef5e,0xedc9,0xec23,0xea6d,0xe8a6,0xe6cf,0xe4e8,0xe2f1,0xe0eb,0xded7,0xdcb3,0xda82,0xd842,0xd5f5,0xd39a,0xd133,0xcebf,0xcc3f,0xc9b3,0xc71c,0xc47a,0xc1cd,0xbf17,0xbc56,0xb98c,0xb6b9,0xb3de,0xb0fb,0xae10,0xab1f,0xa826,0xa527,0xa223,0x9f19,0x9c0b,0x98f8,0x95e1,0x92c7,0x8fab,0x8c8b,0x896a,0x8647,0x8324,0x8000,0x7cdb,0x79b8,0x7695,0x7374,0x7054,0x6d38,0x6a1e,0x6707,0x63f4,0x60e6,0x5ddc,0x5ad8,0x57d9,0x54e0,0x51ef,0x4f04,0x4c21,0x4946,0x4673,0x43a9,0x40e8,0x3e32,0x3b85,0x38e3,0x364c,0x33c0,0x3140,0x2ecc,0x2c65,0x2a0a,0x27bd,0x257d,0x234c,0x2128,0x1f14,0x1d0e,0x1b17,0x1930,0x1759,0x1592,0x13dc,0x1236,0x10a1,0xf1d,0xdab,0xc4a,0xafb,0x9be,0x894,0x77b,0x676,0x583,0x4a3,0x3d6,0x31c,0x276,0x1e2,0x163,0xf6,0x9e,0x59,0x27,0xa,0x0,0xa,0x27,0x59,0x9e,0xf6,0x163,0x1e2,0x276,0x31c,0x3d6,0x4a3,0x583,0x676,0x77b,0x894,0x9be,0xafb,0xc4a,0xdab,0xf1d,0x10a1,0x1236,0x13dc,0x1592,0x1759,0x1930,0x1b17,0x1d0e,0x1f14,0x2128,0x234c,0x257d,0x27bd,0x2a0a,0x2c65,0x2ecc,0x3140,0x33c0,0x364c,0x38e3,0x3b85,0x3e32,0x40e8,0x43a9,0x4673,0x4946,0x4c21,0x4f04,0x51ef,0x54e0,0x57d9,0x5ad8,0x5ddc,0x60e6,0x63f4,0x6707,0x6a1e,0x6d38,0x7054,0x7374,0x7695,0x79b8,0x7cdb,0x8000};


void NCOinitialize(struct NCO *n, uint32_t samp_period){
  n->period = &CT_ECAP.CAP1;
  n->sin_accumulator = 0;
  n->cos_accumulator = (64 <<  16);
  n->sample_period = samp_period;
  n->sin_output = sinLUT[0];
  n->cos_output = sinLUT[64];
  NCOsetfreq(n);
}

void NCOsetfreq(struct NCO *n){
  uint32_t norm_period = 0;
  uint32_t temp_period = 0;

  temp_period = *(n->period) / 100;
  norm_period = P2_24 / temp_period;
  n->incrementor = (uint64_t)norm_period * (uint64_t)n->sample_period;
}

void NCOinterpolate(struct NCO *n){
  uint32_t sin_index, cos_index = 0;
  uint32_t sin_out1, sin_out2 = 0;
  uint32_t cos_out1, cos_out2 = 0;
  uint32_t sin_fraction, cos_fraction = 0;
  uint64_t sin_diff_x_frac, cos_diff_x_frac = 0;
  uint32_t sin_temp_out, cos_temp_out = 0;
  int32_t sin_diff, cos_diff = 0;

  /* Extract int part of accumulator */
  sin_index = n->sin_accumulator >> 16;
  cos_index = n->cos_accumulator >> 16;
  /* Find LUT output and next output */
  sin_out1 = sinLUT[sin_index];
  sin_out2 = sinLUT[sin_index + 1];

  cos_out1 = sinLUT[cos_index];
  cos_out2 = sinLUT[cos_index + 1];

  /* Ectract frac part of accumulator */
  sin_fraction = 0xFFFF & n->sin_accumulator;
  cos_fraction = 0xFFFF & n->cos_accumulator;
  /* Calculate the difference between the 2 samples */
  sin_diff = sin_out2-sin_out1;
  cos_diff = cos_out2-cos_out1;
  /* Multiply by frac part of accumulator */
  sin_diff_x_frac = (int32_t)sin_diff * (uint32_t)sin_fraction;
  cos_diff_x_frac = (int32_t)cos_diff * (uint32_t)cos_fraction;
  /*      Mask least significant 32-bits      */
  /* because we multiply unsigned with signed */
  sin_temp_out = sin_diff_x_frac & 0xFFFFFFFF;
  cos_temp_out = cos_diff_x_frac & 0xFFFFFFFF;

    /*           division by 2^16             */
    /* if temp_out signed convert to unsigned */
    /* after division convert back to signed  */
    /*    if temp_out unsigned just divide    */
    if(sin_temp_out & (1 << 31)){
      sin_temp_out = ~sin_temp_out + 1;
      sin_temp_out /= P2_16;
      sin_temp_out = ~sin_temp_out + 1;
    } else {
      sin_temp_out /= P2_16;
    }

    if(cos_temp_out & (1 << 31)){
      cos_temp_out = ~cos_temp_out + 1;
      cos_temp_out /= P2_16;
      cos_temp_out = ~cos_temp_out + 1;
    } else {
      cos_temp_out /= P2_16;
    }
    n->sin_output = (sin_out1 + sin_temp_out);
    n->cos_output = (cos_out1 + cos_temp_out);
}

void NCOstep(struct NCO *n){
  NCOinterpolate(n);
  n->sin_accumulator = n->sin_accumulator + n->incrementor;
  n->cos_accumulator = n->cos_accumulator + n->incrementor;
  n->sin_accumulator &= (P2_24) - 1;
  n->cos_accumulator &= (P2_24) - 1;
}

#endif
