#ifndef __AM335X_PRU_NCO_C_
#define __AM335X_PRU_NCO_C_

#include <stdio.h>
#include <stdint.h>
#include "am335x_pru_nco.h"

const uint16_t sinLUT[257] = {0x3333,0x3475,0x35b6,0x36f7,0x3838,0x3977,0x3ab6,0x3bf4,0x3d30,0x3e6b,0x3fa4,0x40db,0x4210,0x4342,0x4473,0x45a0,0x46cb,0x47f2,0x4917,0x4a38,0x4b56,0x4c6f,0x4d85,0x4e97,0x4fa5,0x50ae,0x51b3,0x52b3,0x53ae,0x54a4,0x5595,0x5681,0x5767,0x5848,0x5923,0x59f8,0x5ac7,0x5b90,0x5c53,0x5d0f,0x5dc5,0x5e74,0x5f1d,0x5fbf,0x605a,0x60ee,0x617c,0x6202,0x6280,0x62f8,0x6368,0x63d0,0x6432,0x648b,0x64dd,0x6528,0x656a,0x65a5,0x65d8,0x6603,0x6627,0x6642,0x6656,0x6662,0x6666,0x6662,0x6656,0x6642,0x6627,0x6603,0x65d8,0x65a5,0x656a,0x6528,0x64dd,0x648b,0x6432,0x63d0,0x6368,0x62f8,0x6280,0x6202,0x617c,0x60ee,0x605a,0x5fbf,0x5f1d,0x5e74,0x5dc5,0x5d0f,0x5c53,0x5b90,0x5ac7,0x59f8,0x5923,0x5848,0x5767,0x5681,0x5595,0x54a4,0x53ae,0x52b3,0x51b3,0x50ae,0x4fa5,0x4e97,0x4d85,0x4c6f,0x4b56,0x4a38,0x4917,0x47f2,0x46cb,0x45a0,0x4473,0x4342,0x4210,0x40db,0x3fa4,0x3e6b,0x3d30,0x3bf4,0x3ab6,0x3977,0x3838,0x36f7,0x35b6,0x3475,0x3333,0x31f1,0x30b0,0x2f6f,0x2e2e,0x2cef,0x2bb0,0x2a72,0x2936,0x27fb,0x26c2,0x258b,0x2456,0x2324,0x21f3,0x20c6,0x1f9b,0x1e74,0x1d4f,0x1c2e,0x1b10,0x19f7,0x18e1,0x17cf,0x16c1,0x15b8,0x14b3,0x13b3,0x12b8,0x11c2,0x10d1,0xfe5,0xeff,0xe1e,0xd43,0xc6e,0xb9f,0xad6,0xa13,0x957,0x8a1,0x7f2,0x749,0x6a7,0x60c,0x578,0x4ea,0x464,0x3e6,0x36e,0x2fe,0x296,0x234,0x1db,0x189,0x13e,0xfc,0xc1,0x8e,0x63,0x3f,0x24,0x10,0x4,0x0,0x4,0x10,0x24,0x3f,0x63,0x8e,0xc1,0xfc,0x13e,0x189,0x1db,0x234,0x296,0x2fe,0x36e,0x3e6,0x464,0x4ea,0x578,0x60c,0x6a7,0x749,0x7f2,0x8a1,0x957,0xa13,0xad6,0xb9f,0xc6e,0xd43,0xe1e,0xeff,0xfe5,0x10d1,0x11c2,0x12b8,0x13b3,0x14b3,0x15b8,0x16c1,0x17cf,0x18e1,0x19f7,0x1b10,0x1c2e,0x1d4f,0x1e74,0x1f9b,0x20c6,0x21f3,0x2324,0x2456,0x258b,0x26c2,0x27fb,0x2936,0x2a72,0x2bb0,0x2cef,0x2e2e,0x2f6f,0x30b0,0x31f1,0x3333};


void NCOinitialize(struct NCO *n, uint32_t samp_period){
  n->period = &CT_ECAP.CAP1;
  n->sin_accumulator = 0;
  n->cos_accumulator = (64 << 16);
  n->sample_period = samp_period;
  n->sin_output = sinLUT[0];
  n->cos_output = sinLUT[64];
  NCOsetfreq(n);
}

void NCOsetfreq(struct NCO *n){
  uint32_t norm_period = 0;
  uint32_t temp_period = 0;

  temp_period = *(n->period) / 100;
  norm_period = P2_24 / temp_period;
  n->incrementor = (uint64_t)norm_period * (uint64_t)n->sample_period;
}

void NCOinterpolate(struct NCO *n){
  uint32_t sin_index, cos_index = 0;
  uint32_t sin_out1, sin_out2 = 0;
  uint32_t cos_out1, cos_out2 = 0;
  uint32_t sin_fraction, cos_fraction = 0;
  uint64_t sin_diff_x_frac, cos_diff_x_frac = 0;
  uint32_t sin_temp_out, cos_temp_out = 0;
  int32_t sin_diff, cos_diff = 0;

  /* Extract int part of accumulator */
  sin_index = n->sin_accumulator >> 16;
  cos_index = n->cos_accumulator >> 16;
  /* Find LUT output and next output */
  sin_out1 = sinLUT[sin_index];
  sin_out2 = sinLUT[sin_index + 1];

  cos_out1 = sinLUT[cos_index];
  cos_out2 = sinLUT[cos_index + 1];

  /* Ectract frac part of accumulator */
  sin_fraction = 0xFFFF & n->sin_accumulator;
  cos_fraction = 0xFFFF & n->cos_accumulator;
  /* Calculate the difference between the 2 samples */
  sin_diff = sin_out2-sin_out1;
  cos_diff = cos_out2-cos_out1;
  /* Multiply by frac part of accumulator */
  sin_diff_x_frac = (int32_t)sin_diff * (uint32_t)sin_fraction;
  cos_diff_x_frac = (int32_t)cos_diff * (uint32_t)cos_fraction;
  /*      Mask least significant 32-bits      */
  /* because we multiply unsigned with signed */
  sin_temp_out = sin_diff_x_frac & 0xFFFFFFFF;
  cos_temp_out = cos_diff_x_frac & 0xFFFFFFFF;

    /*           division by 2^16             */
    /* if temp_out signed convert to unsigned */
    /* after division convert back to signed  */
    /*    if temp_out unsigned just divide    */
    if(sin_temp_out & (1 << 31)){
      sin_temp_out = ~sin_temp_out + 1;
      sin_temp_out /= P2_16;
      sin_temp_out = ~sin_temp_out + 1;
    } else {
      sin_temp_out /= P2_16;
    }

    if(cos_temp_out & (1 << 31)){
      cos_temp_out = ~cos_temp_out + 1;
      cos_temp_out /= P2_16;
      cos_temp_out = ~cos_temp_out + 1;
    } else {
      cos_temp_out /= P2_16;
    }
    n->sin_output = (sin_out1 + sin_temp_out);
    n->cos_output = (cos_out1 + cos_temp_out);
}

void NCOstep(struct NCO *n){
  NCOinterpolate(n);
  n->sin_accumulator = n->sin_accumulator + n->incrementor;
  n->cos_accumulator = n->cos_accumulator + n->incrementor;
  n->sin_accumulator &= (P2_24) - 1;
  n->cos_accumulator &= (P2_24) - 1;
}

#endif
