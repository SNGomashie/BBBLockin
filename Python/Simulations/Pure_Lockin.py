import numpy as np
import matplotlib.pyplot as plt
from scipy import signal, fftpack


def plot(x, y, z, q, title):
    plt.figure()
    plt.subplot(2, 1, 1)
    plt.title(title)
    plt.plot(x, 'b-')
    plt.plot(y, 'r-')
    plt.subplot(2, 1, 2)
    plt.plot(z, 'b-')
    plt.plot(q, 'r-')


def mplot(x, y, z, q, title, Fs=4000):
    plt.figure()
    plt.subplot(2, 1, 1)
    plt.title(title)
    plt.magnitude_spectrum(x, Fs=Fs, color='blue', scale='dB')
    plt.magnitude_spectrum(y, Fs=Fs, color='red', scale='dB')

    plt.subplot(2, 1, 2)
    plt.magnitude_spectrum(z, Fs=Fs, color='blue', scale='dB')
    plt.magnitude_spectrum(q, Fs=Fs, color='red', scale='dB')


def butter_lowpass(cutoff, fs, order=5):
    nyq = 0.5 * fs
    normal_cutoff = cutoff / nyq
    b, a = signal.butter(order, normal_cutoff, btype='low', analog=False)
    return b, a


def FIR_lowpass(N, cutoff, fs=4000):
    nyq = 0.5 * fs
    taps = signal.firwin(N, cutoff/nyq, window=('hamming'))
    return taps


def pull_input():
    # Generated by BeagleBone Black - PRU-ICSS
    BBBadc = np.int32(np.genfromtxt('adc_out.out', delimiter='\n', unpack=True, dtype=float))
    BBBcos = np.int32(np.genfromtxt('cos_out.out', delimiter='\n', unpack=True, dtype=float))
    BBBsin = np.int32(np.genfromtxt('sin_out.out', delimiter='\n', unpack=True, dtype=float))
    BBB_Qa = np.int32(np.genfromtxt('Qa_out.out', delimiter='\n', unpack=True, dtype=float))
    BBB_In = np.int32(np.genfromtxt('In_out.out', delimiter='\n', unpack=True, dtype=float))
    return BBBsin, BBBcos, BBBadc, BBB_Qa, BBB_In


def generate_input(Fr, Fs, T, Ai, Ar):
    Time = T / Fr
    n = np.linspace(0, Time, int(Fs*Time))
    adc = np.int32(Ai * np.cos((n * 2 * np.pi * Fr) - (np.pi / 10)))
    cos = np.int32(Ar * np.cos(n * 2 * np.pi * Fr))
    sin = np.int32(Ar * np.cos((n * 2 * np.pi * Fr) - (np.pi / 2)))
    return sin, cos, adc


def quadrature(adc, sin, cos):
    Qa = (adc * sin) >> 14
    In = (adc * cos) >> 14
    return Qa, In


def running_mean(x, N):
    cumsum = np.cumsum(np.insert(x, 0, 0))
    return (cumsum[N:] - cumsum[:-N]) / float(N)


def filter(b, a, X, Y):
    X = signal.lfilter(b, a, X)
    Y = signal.lfilter(b, a, Y)
    return X, Y


def decimate(X, Y, M):
    X = signal.decimate(X, M)
    Y = signal.decimate(Y, M)
    return X, Y


def magnitude(Qa, In):
    Ao = np.sqrt((Qa**2)+(In**2))
    return Ao


def scale(Ao):
    Ao *= 1.5259254737998596148564104129154e-4
    return Ao


if __name__ == "__main__":
    plt.close('all')
    Fs = 4000

    # Generate inputs
    BBsin, BBcos, BBadc, Qa, In = pull_input()
    sin, cos, adc = generate_input(Fr=100, Fs=Fs, T=2000, Ai=13107, Ar=32767)

    # plot(sin, adc, BBsin, BBadc, "input signals PY(top) BB(bottom)")
    # mplot(sin, adc, BBsin, BBadc, "FFT input signals PY(top) BB(bottom)")

    # Quadrature
    # Qa, In = quadrature(adc, sin, cos)
    # BBQa, BBIn = quadrature(BBadc, BBsin, BBcos)

    #####################################
    # Lock-in Amplifier with FIR filter #
    #####################################
    taps = FIR_lowpass(4000, 1)  # Calculate coefficients

    FIRQa, FIRIn = filter(taps, 1.0, Qa, In)  # Quadrature filtering

    FIRAo = magnitude(FIRQa, FIRIn)  # Calculate magnitude
    FIRAo = signal.lfilter(taps, 1.0, FIRAo)  # Filter magnitude

    plt.figure()
    plt.subplot(2, 1, 1)
    plt.title("LIA with FIR blackman filter")
    plt.plot(FIRQa, label="Quadrature signal")
    plt.plot(FIRIn, label="In-phase signal")
    plt.plot(FIRAo, label="LIA output")
    plt.ylim(-1500, 15000)
    plt.legend()
    plt.subplot(2, 1, 2)
    plt.title("FFT of LIA with FIR blackman filter")
    plt.magnitude_spectrum(FIRQa, Fs=Fs, color='blue', scale='dB')
    plt.magnitude_spectrum(FIRAo, Fs=Fs, color='red', scale='dB')
    plt.tight_layout()

    #####################################
    # Lock-in Amplifier with IIR filter #
    #####################################
    b, a = butter_lowpass(5, Fs)  # Calculate coefficients

    IIRQa, IIRIn = filter(b, a, Qa, In)  # Quadrature filtering

    IIRAo = magnitude(IIRQa, IIRIn)  # Calculate magnitude
    IIRAo = signal.lfilter(b, a, IIRAo)  # Filter magnitude

    plt.figure()
    plt.subplot(2, 1, 1)
    plt.title("LIA with Butterworth filter")
    plt.plot(IIRQa, label="Quadrature signal")
    plt.plot(IIRIn, label="In-phase signal")
    plt.plot(IIRAo, label="LIA output")
    plt.ylim(-1500, 15000)
    plt.legend()
    plt.subplot(2, 1, 2)
    plt.title("FFT of LIA with butterworth IIR filter")
    plt.magnitude_spectrum(IIRQa, Fs=Fs, color='blue', scale='dB', label="Quadrature signal")
    plt.magnitude_spectrum(IIRAo, Fs=Fs, color='red', scale='dB', label="LIA output")
    plt.legend()
    plt.tight_layout()

    #####################################
    # Lock-in Amplifier with WMA filter #
    #####################################
    N = 12000
    MEANQa = running_mean(Qa, N)  # Filter quadrature
    MEANIn = running_mean(In, N)  # Filter In-phase

    MEANAo = magnitude(MEANQa, MEANIn)  # Calculate magnitude
    MEANAo = running_mean(MEANAo, N)  # Filter magnitude

    plt.figure()
    plt.subplot(2, 1, 1)
    plt.title("LIA with Moving average filter")
    plt.plot(MEANQa, label="Quadrature signal")
    plt.plot(MEANIn, label="In-phase signal")
    plt.plot(MEANAo, label="LIA output")
    plt.ylim(-1500, 15000)
    plt.legend()
    plt.subplot(2, 1, 2)
    plt.title("FFT of LIA with moving average filter")
    plt.magnitude_spectrum(MEANQa, Fs=Fs, color='blue', scale='dB', label="Quadrature signal")
    plt.magnitude_spectrum(MEANAo, Fs=Fs, color='red', scale='dB', label="LIA output")
    plt.legend()
    plt.tight_layout()

    #####################################
    #     Filter frequency responses    #
    #####################################
    plt.figure()
    # FIR Filter #
    FIRw, FIRh = signal.freqz(taps, 1.0, worN=8000)
    plt.subplot(3, 1, 1)
    plt.plot(0.5*Fs*FIRw/np.pi, np.abs(FIRh), 'b')
    plt.xlim(0, 100)
    plt.title("FIR blackman Frequency Response")
    plt.xlabel('Frequency [Hz]')
    plt.grid()
    # IIR Filter #
    w, h = signal.freqz(b, a, worN=8000)
    plt.subplot(3, 1, 2)
    plt.plot(0.5*Fs*w/np.pi, np.abs(h), 'r')
    plt.xlim(0, 100)
    plt.title("IIR butterworth Frequency Response")
    plt.xlabel('Frequency [Hz]')
    plt.grid()
    # Moving average #
    B = np.full(N-1, 1/N)
    MAw, MAh = signal.freqz(B, 1.0, worN=8000)
    plt.subplot(3, 1, 3)
    plt.plot(0.5*Fs*MAw/np.pi, np.abs(MAh), 'r')
    plt.xlim(0, 100)
    plt.title("Moving Average Frequency Response")
    plt.xlabel('Frequency [Hz]')
    plt.grid()
    plt.tight_layout()

    Qa = np.mean(Qa)
    In = np.mean(In)
    Ao = magnitude(Qa, In)
    print("Mean LIA output: %2.5f V, %d LSBs" % (scale(np.mean(Ao)), np.mean(Ao)))

    print("Maximum amplitude from ADC: %2.5f V, %d LSBs" % (scale(np.max(BBadc[10000:])), np.max(BBadc[10000:])))
    print("moving average LIA output: %2.5f V, %d LSBs" % (scale(np.mean(MEANAo[10000:])), np.mean(MEANAo[10000:])))
    print("butterworth LIA output: %2.5f V, %d LSBs" % (scale(np.mean(IIRAo[10000:])), np.mean(IIRAo[10000:])))
    print("FIR hamming LIA output: %2.5f V, %d LSBs" % (scale(np.mean(FIRAo[10000:])), np.mean(FIRAo [10000:])))
